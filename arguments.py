import argparse

# Define constants for the argument names
ADDRESS_ARG = 'address'
LOG_LEVEL_ARG = 'log-level'
TWILIO_ACCOUNT_SID_ARG = 'twilio-account-sid'
TWILIO_AUTH_TOKEN_ARG = 'twilio-auth-token'
TWILIO_FROM_NUMBER_ARG = 'twilio-from-number'
SMS_TO_NUMBER_ARG = 'sms-to-number'
TRANSACTIONS_CHECK_INTERVAL_ARG = 'transactions-check-interval'
SMS_TRANSACTION_DATE_FORMAT_ARG = 'sms-transaction-date-format'
LOG_FORMAT_ARG = 'log-format'
SMS_ENABLE_ARG = 'sms-enable'
WEBHOOK_ENABLE_ARG = 'webhook-enable'
WEBHOOK_URL_ARG = 'webhook-url'
WEBHOOK_SECRET_KEY_ARG = 'webhook-secret-key'

# Define the arguments
arguments = {
    ADDRESS_ARG: {
        'type': str,
        'help': 'Hydra address',
        'required': True
    },
    LOG_LEVEL_ARG: {
        'type': str,
        'help': 'Level of logging',
        'choices': ['NOTSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
        'default': 'INFO'
    },
    TWILIO_ACCOUNT_SID_ARG: {
        'type': str,
        'help': 'Twilio account SID'
    },
    TWILIO_AUTH_TOKEN_ARG: {
        'type': str,
        'help': 'Twilio auth token'
    },
    TWILIO_FROM_NUMBER_ARG: {
        'type': str,
        'help': 'Twilio sms sending phone number'
    },
    SMS_TO_NUMBER_ARG: {
        'type': str,
        'help': 'Number to receive sms notifications'
    },
    TRANSACTIONS_CHECK_INTERVAL_ARG: {
        'type': int,
        'help': 'How often to check for transactions in seconds',
        'default': 3600  # 1 Hour
    },
    SMS_TRANSACTION_DATE_FORMAT_ARG: {
        'type': str,
        'help': 'Datetime format for the transaction date sms. Refer to https://strftime.org/ for available formatting',
        'default': '%d-%b-%Y %H:%M:%S'
    },
    LOG_FORMAT_ARG: {
        'type': str,
        'help': 'Format of the logs. Refer to https://docs.python.org/3/library/logging.html#logrecord-attributes for available formatting',
        'default': '[%(asctime)s] {%(filename)s:%(lineno)d} %(levelname)s - %(message)s'
    },
    SMS_ENABLE_ARG: {
        'type': str,
        'help': 'To enable sms sending',
        'choices': ['yes', 'no'],
        'default': 'no'
    },
    WEBHOOK_ENABLE_ARG: {
        'type': str,
        'help': 'To enable webhook sending',
        'choices': ['yes', 'no'],
        'default': 'no'
    },
    WEBHOOK_URL_ARG: {
        'type': str,
        'help': 'URL for sending the webhook',
        'default': 'http://localhost:5555'
    },
    WEBHOOK_SECRET_KEY_ARG: {
        'type': str,
        'help': 'Secret key, generated by you. Used to hash the content and make secure way to check the validity of the webhook at the receiver side.'
    }
}


class HydraChainArguments:

    def __init__(self):
        parser = argparse.ArgumentParser(description='Hydrachain Staking Notification',
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter)

        for arg_name, arg_attrs in arguments.items():
            parser.add_argument('--{}'.format(arg_name), dest=arg_name, **arg_attrs)

        self.parser = parser
        self.arguments = self.parser.parse_args()
        self._validate_sms_arguments_are_provided()
        self._validate_webhook_arguments_are_provided()

    def get_address(self):
        return self.get_argument(ADDRESS_ARG)

    def get_log_level(self):
        return self.get_argument(LOG_LEVEL_ARG)

    def get_log_format(self):
        return self.get_argument(LOG_FORMAT_ARG)

    def get_twilio_account_sid(self):
        return self.get_argument(TWILIO_ACCOUNT_SID_ARG)

    def get_twilio_auth_token(self):
        return self.get_argument(TWILIO_AUTH_TOKEN_ARG)

    def get_twilio_from_number(self):
        return self.get_argument(TWILIO_FROM_NUMBER_ARG)

    def get_sms_to_number(self):
        return self.get_argument(SMS_TO_NUMBER_ARG)

    def get_transactions_check_interval(self):
        return self.get_argument(TRANSACTIONS_CHECK_INTERVAL_ARG)

    def get_sms_transaction_date_format(self):
        return self.get_argument(SMS_TRANSACTION_DATE_FORMAT_ARG)

    def get_sms_enable(self):
        smsEnableArgumentValue = self.get_argument(SMS_ENABLE_ARG)

        return True if smsEnableArgumentValue == 'yes' else False

    def get_webhook_enable(self):
        webhookEnableArgument = self.get_argument(WEBHOOK_ENABLE_ARG)

        return True if webhookEnableArgument == 'yes' else False

    def get_webhook_url(self):
        return self.get_argument(WEBHOOK_URL_ARG)

    def get_webhook_secret(self):
        return self.get_argument(WEBHOOK_SECRET_KEY_ARG)

    def get_argument(self, argument):
        return self.arguments.__getattribute__(argument)

    def _validate_webhook_arguments_are_provided(self):

        if not self.get_webhook_enable():
            return

        required_arguments = [WEBHOOK_SECRET_KEY_ARG]

        self._validate_arguments_present(WEBHOOK_ENABLE_ARG, required_arguments)

    def _validate_sms_arguments_are_provided(self):

        if not self.get_sms_enable():
            return

        required_arguments = [TWILIO_ACCOUNT_SID_ARG, TWILIO_AUTH_TOKEN_ARG, TWILIO_FROM_NUMBER_ARG,
                              SMS_TO_NUMBER_ARG]
        self._validate_arguments_present(SMS_ENABLE_ARG, required_arguments)

    def _validate_arguments_present(self, argument, required_arguments):
        missing_required_arguments = self.get_arguments_with_none_value(required_arguments)
        missing_required_arguments_with_prefix = self.prefix_strings('--', missing_required_arguments)

        if len(missing_required_arguments_with_prefix) > 0:
            error_message = 'Argument --{} requires additional arguments: {}'.format(
                argument, ', '.join(missing_required_arguments_with_prefix))
            self.parser.error(error_message)

    def get_arguments(self):
        return self.arguments

    def check_not_none_values(*values):
        return all(value is not None for value in values)

    def get_arguments_with_none_value(self, arguments):
        arguments_with_none_value = []

        for argument in arguments:
            argument_value = self.get_argument(argument)
            arguments_with_none_value.append(argument) if argument_value == None else None

        return arguments_with_none_value

    def prefix_strings(self, prefix, strings):
        return [prefix + s for s in strings]
